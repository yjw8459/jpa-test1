JPA에서 가장 중요한 2가지


1. 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping)

2. 영속성 컨텍스트
"엔티티를 영구 저장하는 환경"이라는 뜻
EntityManager.persist(entity)
영속성 컨텍스트로 엔티티를 영속화한다.
영속성 컨텍스트는 논리적인 개념이다. 눈에 보이지 않으며, 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.
엔티티매니저를 생성하면 1:1로 영속성 컨텍스트가 생성이 된다.

영속성 컨텍스트의 장점
영속성 컨텍스트는 캐싱을 사용하여, DB에서 조회하기 전에 영속성 컨텍스트에서 먼저 엔티티가 있는지 조회한다.

엔티티의 생명주기
비영속(new/transient)
영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
영속성 컨텍스트에서 관리하지 않는 엔티티

준영속, 삭제
detach()로 영속상태 제외 가능하다.


영속(Managed)
엔티티를 persist하면 먼저 1차캐시에 저장되고, 쓰기 지연 SQL 저장소에 저장된다.
그렇게 쌓인 SQL들은 트랜잭션을 commit하는 시점에 쓰기 지연 SQL 저장소에 있던 SQL들이 한꺼번에 날아가고 커밋된다.(flush)

변경감지(dirty Checking)
값을 읽어온 최초 시점에 스냅샷을 남겨두고, 트랜잭션 커밋하는 시점에 스냅샷과 엔티티를 비교한다.
변경된 엔티티는 업데이트 쿼리를 날린다.
영속화된 데이터를 변경하였다가, 다시 원상복구하면 변경감지가 되지 않는다.


flush(동기화)
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
 - 변경감지
 - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
 - 쓰기 지연 SQL 저장소에 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

 em.flush() : 직접호출
 또는 Commit 시점에 호출된다.
 flush를 하여도 쓰기 지연 SQL 저장소만 반영될 뿐, 1차 캐시는 지워지지 않는다.
 - 영속성 컨텍스트는 비우지 않음.
 - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
 - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨

 flush 모드 옵션
 em.setFlushMode(FlushModeType.COMMIT)
 FlushModeType.AUTO : 커밋이나 쿼리를 실핼할 때 플러시(기본값)
 FlushModeType.COMMIT : 커밋할 때만 플러시
 AUTO를 사용하는 것을 권장.

 준영속상태
 - 영속 -> 준영속
 - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
 - 영속성 컨텍스트가 제공하는 기능을 사용하지 못함.