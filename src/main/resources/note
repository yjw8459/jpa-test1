JPA에서 가장 중요한 2가지


1. 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping)

2. 영속성 컨텍스트
"엔티티를 영구 저장하는 환경"이라는 뜻
EntityManager.persist(entity)
영속성 컨텍스트로 엔티티를 영속화한다.
영속성 컨텍스트는 논리적인 개념이다. 눈에 보이지 않으며, 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.
엔티티매니저를 생성하면 1:1로 영속성 컨텍스트가 생성이 된다.

영속성 컨텍스트의 장점
영속성 컨텍스트는 캐싱을 사용하여, DB에서 조회하기 전에 영속성 컨텍스트에서 먼저 엔티티가 있는지 조회한다.

엔티티의 생명주기
비영속(new/transient)
영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
영속성 컨텍스트에서 관리하지 않는 엔티티

준영속, 삭제
detach()로 영속상태 제외 가능하다.


영속(Managed)
엔티티를 persist하면 먼저 1차캐시에 저장되고, 쓰기 지연 SQL 저장소에 저장된다.
그렇게 쌓인 SQL들은 트랜잭션을 commit하는 시점에 쓰기 지연 SQL 저장소에 있던 SQL들이 한꺼번에 날아가고 커밋된다.(flush)

변경감지(dirty Checking)
값을 읽어온 최초 시점에 스냅샷을 남겨두고, 트랜잭션 커밋하는 시점에 스냅샷과 엔티티를 비교한다.
변경된 엔티티는 업데이트 쿼리를 날린다.
영속화된 데이터를 변경하였다가, 다시 원상복구하면 변경감지가 되지 않는다.


flush(동기화)
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
 - 변경감지
 - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
 - 쓰기 지연 SQL 저장소에 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

 em.flush() : 직접호출
 또는 Commit 시점에 호출된다.
 flush를 하여도 쓰기 지연 SQL 저장소만 반영될 뿐, 1차 캐시는 지워지지 않는다.
 - 영속성 컨텍스트는 비우지 않음.
 - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
 - 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨

 flush 모드 옵션
 em.setFlushMode(FlushModeType.COMMIT)
 FlushModeType.AUTO : 커밋이나 쿼리를 실핼할 때 플러시(기본값)
 FlushModeType.COMMIT : 커밋할 때만 플러시
 AUTO를 사용하는 것을 권장.

 준영속상태
 - 영속 -> 준영속
 - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
 - 영속성 컨텍스트가 제공하는 기능을 사용하지 못함.

 객체와 테이블 매핑
 @Entity가 붙은 클래스는 JPA가 관리하는 엔티티
 JPA를 사용해서 테이블과 매핑할 클래스는 @Entity가 필수
 주의
 - 기본 생성자 필수(@NoArgsConstructor)
 - final 클래스, enum, interface, inner 클래스 사용 X
 - 저장할 필드에 final 사용 X

 데이터베이스 스키마 자동 생성
 - DDL을 애플리케이션 실행 시점에 자동 생성
 - 테이블 중심 -> 객체 중심
 - 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
 - 이렇게 생성된 DDL은 개발 장비에서만 사용해야 한다.
 create 삭제 후 생성
 create-drop 은 생성 후 애플리케이션 종료 시점에 drop
 update 변경분만 반영, (테이블 생성, 삭제, 컬럼 추가 등 변경 내용만 반영)
 validate 엔티티와 테이블이 정상 매핑되었는지 확인해줌.
 none 사용하지 않음.

 개발 초기는 create 또는 update
 테스트 서버는 update 또는 validate
 스테이징과 운영 서버는 validate 또는 none

 필드와 컬럼 매핑

